<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Road System - Multiple Cameras</title>
    <!-- Import Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for smoother video display */
        .camera-feed-image {
            image-rendering: optimizeSpeed;
            min-height: 240px;
            background-color: #000;
        }
        
        /* Optimize animation performance */
        .optimize-animation {
            backface-visibility: hidden;
            transform: translateZ(0);
            perspective: 1000px;
        }
        
        /* Camera feed container */
        .camera-container {
            transition: all 0.3s ease;
        }
        
        .camera-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        /* Selected camera highlight */
        .camera-selected {
            border: 2px solid #3B82F6;
        }
        
        /* Detection bounding box styles */
        .detection-box {
            position: absolute;
            border: 2px solid;
            border-radius: 2px;
            pointer-events: none;
            transition: all 0.1s ease;
            z-index: 10;
        }
        
        .detection-label {
            position: absolute;
            top: -20px;
            left: 0;
            font-size: 12px;
            padding: 2px 4px;
            border-radius: 2px;
            color: white;
            font-weight: bold;
            white-space: nowrap;
        }
        
        /* Object class colors */
        .box-person { border-color: #FF3B30; }
        .box-car { border-color: #34C759; }
        .box-truck { border-color: #007AFF; }
        .box-bicycle { border-color: #FF9500; }
        .box-motorcycle { border-color: #AF52DE; }
        .box-bus { border-color: #5856D6; }
        
        .label-person { background-color: #FF3B30; }
        .label-car { background-color: #34C759; }
        .label-truck { background-color: #007AFF; }
        .label-bicycle { background-color: #FF9500; }
        .label-motorcycle { background-color: #AF52DE; }
        .label-bus { background-color: #5856D6; }
        
        /* Default for other classes */
        .box-default { border-color: #FF2D55; }
        .label-default { background-color: #FF2D55; }
        
        /* Training panel styling */
        .training-panel {
            border-top: 1px solid #e5e7eb;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4">
        <h1 class="text-4xl font-bold text-center text-blue-600 mb-6">Smart Road System</h1>
        
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-semibold">Camera Feeds</h2>
            <div class="flex items-center gap-4">
                <p class="status text-lg">Connection: <span id="connectionStatus" class="text-red-500 font-medium">Disconnected</span></p>
                <button id="connectBtn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">Connect</button>
            </div>
        </div>
        
        <!-- Camera feeds grid -->
        <div id="cameraGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
            <div class="flex items-center justify-center p-6 bg-white rounded-lg shadow">
                <p class="text-gray-400">Waiting for cameras to connect...</p>
            </div>
        </div>
        
        <!-- Selected camera detail view -->
        <div id="selectedCamera" class="bg-white shadow-md rounded-lg p-4 mb-6 hidden">
            <div class="flex flex-col md:flex-row gap-6">
                <div class="md:w-2/3">
                    <div class="relative">
                        <img id="mainVideoFeed" class="w-full rounded-md border border-gray-300 camera-feed-image optimize-animation" alt="Selected Camera Feed">
                        <div id="loadingIndicator" class="absolute top-0 left-0 w-full h-full flex items-center justify-center bg-black bg-opacity-50 rounded-md">
                            <div class="text-white text-lg">Waiting for camera feed...</div>
                        </div>
                        <div id="cameraIdLabel" class="absolute top-2 left-2 bg-black bg-opacity-70 text-white px-2 py-1 rounded text-sm"></div>
                        <!-- Container for bounding boxes -->
                        <div id="detectionBoxes" class="absolute top-0 left-0 w-full h-full"></div>
                    </div>
                    <div class="flex justify-between items-center mt-4">
                        <button id="captureBtn" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">Capture Screenshot</button>
                        <div class="stats text-right">
                            <p class="text-sm text-gray-600">FPS: <span id="fpsCounter">0</span></p>
                            <p class="text-sm text-gray-600">Frames: <span id="frameCount">0</span></p>
                            <p class="text-sm text-gray-600">Detections: <span id="detectionCount">0</span></p>
                        </div>
                    </div>
                </div>
                <div class="md:w-1/3">
                    <h3 class="text-xl font-bold text-gray-700 mb-3">Camera Information</h3>
                    <div id="cameraInfo" class="text-gray-600 space-y-2">No camera selected</div>
                    
                    <div class="mt-6">
                        <h3 class="text-xl font-bold text-gray-700 mb-3">Detection Settings</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="flex items-center space-x-2">
                                    <input id="showDetections" type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" checked>
                                    <span>Show detection boxes</span>
                                </label>
                            </div>
                            <div>
                                <label class="block text-sm mb-1">Confidence threshold</label>
                                <div class="flex items-center space-x-2">
                                    <label for="confidenceSlider" class="block text-sm font-medium text-gray-700">Confidence Slider</label>
                                    <input id="confidenceSlider" type="range" min="10" max="90" value="25" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" title="Adjust confidence threshold">
                                    <span id="confidenceValue" class="text-sm font-medium">0.25</span>
                                </div>
                            </div>
                        </div> 
                    </div>
                    
                    <!-- Training panel -->
                    <div class="mt-6 pt-4 training-panel">
                        <h3 class="text-xl font-bold text-gray-700 mb-3">Model Training</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm mb-1">Training epochs</label>
                                <label for="trainingEpochs" class="block text-sm font-medium text-gray-700">Training Epochs</label>
                                <input id="trainingEpochs" type="number" min="1" max="100" value="10" class="w-full px-3 py-2 border border-gray-300 rounded" placeholder="Enter number of epochs" title="Number of training epochs">
                            </div>
                            <div>
                                <label class="block text-sm mb-1">Batch size</label>
                                <input id="batchSize" type="number" min="1" max="64" value="16" class="w-full px-3 py-2 border border-gray-300 rounded" title="Enter batch size" placeholder="Batch size">
                            </div>
                            <div class="flex gap-2">
                                <button id="startTrainingBtn" class="flex-1 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition">Start Training</button>
                                <button id="stopTrainingBtn" class="flex-1 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition" disabled>Stop</button>
                            </div>
                            <div id="trainingStatus" class="text-sm text-gray-600 mt-2 hidden">
                                <div class="flex items-center justify-between mb-1">
                                    <span>Progress:</span>
                                    <span id="trainingProgress">0%</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2.5">
                                    <div id="trainingProgressBar" class="bg-purple-600 h-2.5 rounded-full" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Main elements
            const cameraGrid = document.getElementById('cameraGrid');
            const selectedCamera = document.getElementById('selectedCamera');
            const mainVideoFeed = document.getElementById('mainVideoFeed');
            const cameraIdLabel = document.getElementById('cameraIdLabel');
            const connectionStatus = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const captureBtn = document.getElementById('captureBtn');
            const cameraInfo = document.getElementById('cameraInfo');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const frameCount = document.getElementById('frameCount');
            const fpsCounter = document.getElementById('fpsCounter');
            const detectionCount = document.getElementById('detectionCount');
            const detectionBoxes = document.getElementById('detectionBoxes');
            const showDetections = document.getElementById('showDetections');
            const confidenceSlider = document.getElementById('confidenceSlider');
            const confidenceValue = document.getElementById('confidenceValue');
            
            // Training elements
            const trainingEpochs = document.getElementById('trainingEpochs');
            const batchSize = document.getElementById('batchSize');
            const startTrainingBtn = document.getElementById('startTrainingBtn');
            const stopTrainingBtn = document.getElementById('stopTrainingBtn');
            const trainingStatus = document.getElementById('trainingStatus');
            const trainingProgress = document.getElementById('trainingProgress');
            const trainingProgressBar = document.getElementById('trainingProgressBar');
            
            // State management
            let ws = null;
            let frameCounter = 0;
            let isConnecting = false;
            let latestObjectURLs = new Map(); // Map of cameraId -> objectURL
            let activeCameraId = null;
            let cameraMetadata = new Map(); // Map of cameraId -> camera info
            let isTraining = false;
            let trainingJob = null;
            
            // Performance monitoring
            const fpsMonitor = {
                frameCount: 0,
                lastCheck: performance.now(),
                fps: 0,
                
                tick() {
                    this.frameCount++;
                    const now = performance.now();
                    const elapsed = now - this.lastCheck;
                    
                    // Update FPS counter every 500ms
                    if (elapsed >= 500) {
                        this.fps = Math.round((this.frameCount * 1000) / elapsed);
                        fpsCounter.textContent = this.fps;
                        this.frameCount = 0;
                        this.lastCheck = now;
                    }
                }
            };
            
            // Connect to WebSocket server
            function connectWebSocket() {
                if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                    return; // Already connecting or connected
                }
                
                isConnecting = true;
                connectionStatus.textContent = 'Connecting...';
                connectionStatus.className = 'text-yellow-500 font-medium';
                
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsURL = `${protocol}//${window.location.host}/?type=browser`;
                
                ws = new WebSocket(wsURL);
                
                // Set binary type explicitly for better performance with images
                ws.binaryType = 'arraybuffer';
                
                ws.onopen = () => {
                    isConnecting = false;
                    connectionStatus.textContent = 'Connected';
                    connectionStatus.className = 'text-green-500 font-medium';
                    connectBtn.textContent = 'Disconnect';
                    
                    // Request camera list upon connection
                    try {
                        ws.send(JSON.stringify({command: 'list_cameras'}));
                    } catch (e) {
                        console.error('Error sending initial command:', e);
                    }
                };
                
                ws.onclose = (event) => {
                    isConnecting = false;
                    connectionStatus.textContent = 'Disconnected';
                    connectionStatus.className = 'text-red-500 font-medium';
                    connectBtn.textContent = 'Connect';
                    
                    // Clear camera grid and show waiting message
                    cameraGrid.innerHTML = `
                        <div class="flex items-center justify-center p-6 bg-white rounded-lg shadow">
                            <p class="text-gray-400">Waiting for connection...</p>
                        </div>
                    `;
                    
                    // Hide selected camera view
                    selectedCamera.classList.add('hidden');
                    
                    // Auto-reconnect after a delay
                    setTimeout(() => {
                        if (!isConnecting && (!ws || ws.readyState !== WebSocket.OPEN)) {
                            connectWebSocket();
                        }
                    }, 2000);
                };
                
                ws.onerror = (error) => {
                    isConnecting = false;
                    console.error('WebSocket error:', error);
                    connectionStatus.textContent = 'Error';
                    connectionStatus.className = 'text-red-500 font-medium';
                };
                
                // Handle incoming messages
                ws.onmessage = (event) => {
                    // Handle binary data (video frames)
                    if (event.data instanceof ArrayBuffer) {
                        // We should have received frame metadata already
                        if (currentFrameMetadata) {
                            handleVideoFrame(event.data, currentFrameMetadata);
                            currentFrameMetadata = null;
                        } else {
                            console.error('Received binary frame without metadata');
                        }
                    } 
                    // Handle text messages (JSON)
                    else {
                        try {
                            const message = JSON.parse(event.data);
                            
                            // Handle different message types
                            switch (message.type) {
                                case 'camera_list':
                                    handleCameraList(message.cameras);
                                    break;
                                    
                                case 'camera_info':
                                    handleCameraInfo(message);
                                    break;
                                    
                                case 'camera_disconnected':
                                    handleCameraDisconnected(message.id);
                                    break;
                                    
                                case 'frame_metadata':
                                    // Store metadata for next binary frame
                                    currentFrameMetadata = message;
                                    break;
                                    
                                case 'detection_results':
                                    renderDetectionBoxes(message);
                                    break;
                                
                                case 'training_status':
                                    updateTrainingStatus(message);
                                    break;
                                    
                                case 'detection_config':
                                    // Update config UI
                                    confidenceSlider.value = Math.round(message.confidenceThreshold * 100);
                                    confidenceValue.textContent = message.confidenceThreshold.toFixed(2);
                                    break;
                            }
                        } catch (error) {
                            console.error('Error parsing message:', error);
                        }
                    }
                };
            }
            
            // Variable to store current frame metadata
            let currentFrameMetadata = null;
            
            // Handle camera list message
            function handleCameraList(cameras) {
                if (!cameras || cameras.length === 0) {
                    cameraGrid.innerHTML = `
                        <div class="flex items-center justify-center p-6 bg-white rounded-lg shadow">
                            <p class="text-gray-400">No cameras connected</p>
                        </div>
                    `;
                    return;
                }
                
                // Update camera metadata cache
                cameras.forEach(camera => {
                    cameraMetadata.set(camera.id, camera);
                });
                
                // Rebuild camera grid
                cameraGrid.innerHTML = '';
                
                cameras.forEach(camera => {
                    const cameraCard = document.createElement('div');
                    const isConnected = camera.connected;
                    const isSelected = camera.id === activeCameraId;
                    
                    cameraCard.className = `camera-container bg-white rounded-lg shadow overflow-hidden 
                                         ${isSelected ? 'camera-selected' : ''} 
                                         ${!isConnected ? 'opacity-60' : ''}`;
                    cameraCard.id = `camera-card-${camera.id}`;
                    
                    cameraCard.innerHTML = `
                        <div class="relative">
                            <img id="feed-${camera.id}" class="w-full h-48 object-cover camera-feed-image" 
                                 src="${isConnected ? '' : 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' fill=\'none\' viewBox=\'0 0 24 24\' stroke=\'%23374151\'%3E%3Cpath stroke-linecap=\'round\' stroke-linejoin=\'round\' stroke-width=\'2\' d=\'M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z\' /%3E%3C/svg%3E'}" 
                                 alt="${camera.id}">
                            <div class="absolute top-2 left-2 bg-black bg-opacity-70 text-white px-2 py-1 rounded text-sm">
                                ${camera.id}
                            </div>
                            <div class="absolute bottom-2 right-2 ${isConnected ? 'bg-green-500' : 'bg-red-500'} rounded-full h-3 w-3"></div>
                        </div>
                        <div class="p-4">
                            <h3 class="font-bold">${camera.position || camera.id}</h3>
                            <p class="text-sm text-gray-600">${isConnected ? 'Connected' : 'Disconnected'}</p>
                        </div>
                    `;
                    
                    // Add click handler to select camera
                    cameraCard.addEventListener('click', () => {
                        if (isConnected) {
                            selectCamera(camera.id);
                        }
                    });
                    
                    cameraGrid.appendChild(cameraCard);
                });
                
                // If we have an active camera, ensure it's still selected
                if (activeCameraId && cameraMetadata.has(activeCameraId)) {
                    selectCamera(activeCameraId);
                } 
                // Otherwise select the first connected camera
                else {
                    const firstConnectedCamera = cameras.find(camera => camera.connected);
                    if (firstConnectedCamera) {
                        selectCamera(firstConnectedCamera.id);
                    }
                }
            }
            
            // Handle camera info update
            function handleCameraInfo(info) {
                // Update metadata
                cameraMetadata.set(info.id, info);
                
                // Update selected camera info if this is the active one
                if (info.id === activeCameraId) {
                    updateSelectedCameraInfo();
                }
            }
            
            // Handle camera disconnection
            function handleCameraDisconnected(cameraId) {
                const cameraCard = document.getElementById(`camera-card-${cameraId}`);
                if (cameraCard) {
                    // Update UI to show disconnected state
                    const statusIndicator = cameraCard.querySelector('.rounded-full');
                    if (statusIndicator) {
                        statusIndicator.className = 'absolute bottom-2 right-2 bg-red-500 rounded-full h-3 w-3';
                    }
                    
                    const statusText = cameraCard.querySelector('p.text-sm');
                    if (statusText) {
                        statusText.textContent = 'Disconnected';
                    }
                    
                    cameraCard.classList.add('opacity-60');
                }
                
                // If this was the active camera, hide the main view
                if (cameraId === activeCameraId) {
                    selectedCamera.classList.add('hidden');
                    activeCameraId = null;
                }
            }
            
            // Select camera to display in the main view
            function selectCamera(cameraId) {
                // Update active camera
                activeCameraId = cameraId;
                
                // Update UI selection state
                document.querySelectorAll('.camera-container').forEach(card => {
                    card.classList.remove('camera-selected');
                });
                
                const selectedCard = document.getElementById(`camera-card-${cameraId}`);
                if (selectedCard) {
                    selectedCard.classList.add('camera-selected');
                }
                
                // Show selected camera view
                selectedCamera.classList.remove('hidden');
                
                // Update camera label
                cameraIdLabel.textContent = cameraId;
                
                // Update camera info
                updateSelectedCameraInfo();
                
                // Reset frame counter
                frameCounter = 0;
                frameCount.textContent = '0';
                
                // Reset detection counter
                detectionCount.textContent = '0';
                
                // Show loading indicator
                loadingIndicator.style.display = 'flex';
                
                // Clear previous detection boxes
                detectionBoxes.innerHTML = '';
                
                // Request the latest frame
                if (ws && ws.readyState === WebSocket.OPEN) {
                    try {
                        ws.send(JSON.stringify({
                            command: 'get_latest_frame',
                            cameraId: cameraId
                        }));
                        
                        // Also request latest detections
                        ws.send(JSON.stringify({
                            command: 'get_latest_detections',
                            cameraId: cameraId
                        }));
                    } catch (e) {
                        console.error('Error requesting latest frame:', e);
                    }
                }
            }
            
            // Update the selected camera info panel
            function updateSelectedCameraInfo() {
                if (!activeCameraId || !cameraMetadata.has(activeCameraId)) {
                    cameraInfo.innerHTML = 'No camera selected';
                    return;
                }
                
                const info = cameraMetadata.get(activeCameraId);
                
                cameraInfo.innerHTML = `
                    <p><span class="font-semibold">ID:</span> ${info.id}</p>
                    <p><span class="font-semibold">Position:</span> ${info.position || 'Not specified'}</p>
                    <p><span class="font-semibold">Description:</span> ${info.description || 'No description'}</p>
                    <p><span class="font-semibold">Resolution:</span> ${info.resolution || 'Unknown'}</p>
                    <p><span class="font-semibold">Frame Rate:</span> ${info.fps || 'Unknown'} FPS</p>
                    <p><span class="font-semibold">Status:</span> 
                        <span class="${info.connected ? 'text-green-500' : 'text-red-500'}">
                            ${info.connected ? 'Connected' : 'Disconnected'}
                        </span>
                    </p>
                `;
            }
            
            // Handle incoming video frame
            function handleVideoFrame(arrayBuffer, metadata) {
                const cameraId = metadata.id;
                
                // Create a blob from the array buffer
                const blob = new Blob([arrayBuffer], {type: 'image/jpeg'});
                
                // Clean up previous object URL for this camera if exists
                if (latestObjectURLs.has(cameraId)) {
                    URL.revokeObjectURL(latestObjectURLs.get(cameraId));
                }
                
                // Create new object URL
                const objectUrl = URL.createObjectURL(blob);
                latestObjectURLs.set(cameraId, objectUrl);
                
                // Update the thumbnail for this camera
                const thumbnailImage = document.getElementById(`feed-${cameraId}`);
                if (thumbnailImage) {
                    thumbnailImage.src = objectUrl;
                }
                
                // If this is the selected camera, update the main feed too
                if (cameraId === activeCameraId) {
                    requestAnimationFrame(() => {
                        // Update the main video feed
                        mainVideoFeed.src = objectUrl;
                        
                        // Hide loading indicator once we get the first frame
                        if (loadingIndicator.style.display !== 'none') {
                            loadingIndicator.style.display = 'none';
                        }
                        
                        // Update frame counter
                        frameCounter++;
                        frameCount.textContent = frameCounter;
                        
                        // Update FPS counter
                        fpsMonitor.tick();
                    });
                }
            }
            
            // Render detection boxes on the current frame
            function renderDetectionBoxes(results) {
                if (!results || !results.detections || !showDetections.checked || results.cameraId !== activeCameraId) {
                    return;
                }
                
                // Get parent element dimensions for accurate positioning
                const containerWidth = mainVideoFeed.offsetWidth;
                const containerHeight = mainVideoFeed.offsetHeight;
                
                detectionBoxes.innerHTML = '';
                detectionCount.textContent = results.detections.length;
                
                // Iterating through each detection
                results.detections.forEach(detection => {
                    // Extract normalized coordinates from bbox
                    const [x1, y1, x2, y2] = detection.bbox;
                    
                    // Calculate width and height
                    const x = x1;
                    const y = y1;
                    const width = x2 - x1;
                    const height = y2 - y1;
                    
                    // Create and style the bounding box
                    const box = document.createElement('div');
                    const classNameSafe = detection.class_name.toLowerCase().replace(/[^a-z0-9]/g, '-');
                    
                    box.className = `detection-box box-${classNameSafe}`;
                    box.style.left = `${x * 100}%`;
                    box.style.top = `${y * 100}%`;
                    box.style.width = `${width * 100}%`;
                    box.style.height = `${height * 100}%`;
                    
                    // Create the label
                    const label = document.createElement('div');
                    label.className = `detection-label label-${classNameSafe}`;
                    const percent = (detection.confidence * 100).toFixed(1);
                    label.textContent = `${detection.class_name} (${percent}%)`;
                    
                    // Position the label above the box
                    box.appendChild(label);
                    detectionBoxes.appendChild(box);
                });
            }
            
            // Start model training
            async function startTraining() {
                if (isTraining || !ws || ws.readyState !== WebSocket.OPEN) {
                    return;
                }
                
                // Get training parameters
                const epochs = parseInt(trainingEpochs.value) || 10;
                const batch = parseInt(batchSize.value) || 16;
                
                // Update UI
                startTrainingBtn.disabled = true;
                stopTrainingBtn.disabled = false;
                trainingStatus.classList.remove('hidden');
                trainingProgress.textContent = '0%';
                trainingProgressBar.style.width = '0%';
                isTraining = true;
                
                // Send training command
                try {
                    ws.send(JSON.stringify({
                        command: 'train_model',
                        epochs: epochs,
                        batch_size: batch,
                        timestamp: Date.now()
                    }));
                } catch (e) {
                    console.error('Error starting training:', e);
                    stopTraining();
                }
            }
            
            // Stop ongoing training
            function stopTraining() {
                if (!isTraining) return;
                
                // Send stop command if connected
                if (ws && ws.readyState === WebSocket.OPEN) {
                    try {
                        ws.send(JSON.stringify({
                            command: 'stop_training',
                            timestamp: Date.now()
                        }));
                    } catch (e) {
                        console.error('Error stopping training:', e);
                    }
                }
                
                // Update UI
                startTrainingBtn.disabled = false;
                stopTrainingBtn.disabled = true;
                isTraining = false;
            }
            
            // Update training status based on server message
            function updateTrainingStatus(status) {
                if (!status) return;
                
                if (status.status === 'running') {
                    // Update progress
                    const percent = Math.round((status.current_epoch / status.total_epochs) * 100);
                    trainingProgress.textContent = `${percent}% (Epoch ${status.current_epoch}/${status.total_epochs})`;
                    trainingProgressBar.style.width = `${percent}%`;
                    
                    // Make sure UI shows training state
                    startTrainingBtn.disabled = true;
                    stopTrainingBtn.disabled = false;
                    trainingStatus.classList.remove('hidden');
                    isTraining = true;
                } 
                else if (status.status === 'completed') {
                    // Training successfully completed
                    trainingProgress.textContent = '100% (Completed)';
                    trainingProgressBar.style.width = '100%';
                    
                    // Reset UI state after a moment
                    setTimeout(() => {
                        startTrainingBtn.disabled = false;
                        stopTrainingBtn.disabled = true;
                        isTraining = false;
                    }, 2000);
                } 
                else if (status.status === 'error') {
                    // Training error
                    trainingProgress.textContent = `Error: ${status.message || 'Unknown error'}`;
                    trainingProgressBar.style.width = '0%';
                    startTrainingBtn.disabled = false;
                    stopTrainingBtn.disabled = true;
                    isTraining = false;
                }
            }
            
            // Show/hide detection boxes
            showDetections.addEventListener('change', () => {
                if (!showDetections.checked) {
                    detectionBoxes.innerHTML = '';
                } else if (activeCameraId) {
                    // Request latest detections again
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            command: 'get_latest_detections',
                            cameraId: activeCameraId
                        }));
                    }
                }
            });
            
            // Update confidence threshold
            confidenceSlider.addEventListener('input', () => {
                const newValue = confidenceSlider.value / 100;
                confidenceValue.textContent = newValue.toFixed(2);
                
                // Debounce sending updates to server
                clearTimeout(confidenceSlider.timeout);
                confidenceSlider.timeout = setTimeout(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            command: 'set_detection_config',
                            confidence: newValue,
                            timestamp: Date.now()
                        }));
                    }
                }, 300);
            });
            
            // Capture screenshot of current camera view
            captureBtn.addEventListener('click', () => {
                if (mainVideoFeed.src && activeCameraId) {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = mainVideoFeed.naturalWidth || 640;
                        canvas.height = mainVideoFeed.naturalHeight || 480;
                        
                        const context = canvas.getContext('2d');
                        context.drawImage(mainVideoFeed, 0, 0);
                        
                        const link = document.createElement('a');
                        link.download = `${activeCameraId}_${new Date().toISOString().replace(/:/g, '-')}.jpg`;
                        link.href = canvas.toDataURL('image/jpeg');
                        link.click();
                    } catch (error) {
                        console.error('Error capturing screenshot:', error);
                    }
                }
            });
            
            // Connect/disconnect button
            connectBtn.addEventListener('click', () => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.close();
                } else if (!isConnecting) {
                    connectWebSocket();
                }
            });
            
            // Training control buttons
            startTrainingBtn.addEventListener('click', startTraining);
            stopTrainingBtn.addEventListener('click', stopTraining);
            
            // Initial connection
            connectWebSocket();
        });
    </script>
</body>
</html>